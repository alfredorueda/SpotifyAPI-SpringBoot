package com.spotify.unit.service;

import com.spotify.domain.entities.Playlist;
import com.spotify.domain.entities.Track;
import com.spotify.domain.exceptions.InvalidTrackPositionException;
import com.spotify.domain.exceptions.PlaylistNotFoundException;
import com.spotify.domain.exceptions.TrackNotFoundException;
import com.spotify.dto.AddMultipleTracksRequest;
import com.spotify.repositories.PlaylistRepository;
import com.spotify.services.PlaylistService;
import com.spotify.services.TrackService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

/**
 * Unit tests for PlaylistService using Mockito to mock dependencies.
 * These tests focus on service coordination logic and interaction between services.
 * 
 * @Tag("unit") allows running only unit tests with: mvn test -Dtest="*Test" -Dgroups="unit"
 */
@Tag("unit")
@ExtendWith(MockitoExtension.class)
@DisplayName("PlaylistService Unit Tests")
class PlaylistServiceTest {

    @Mock
    private PlaylistRepository playlistRepository;

    @Mock
    private TrackService trackService;

    @InjectMocks
    private PlaylistService playlistService;

    private Playlist samplePlaylist;
    private Track sampleTrack1;
    private Track sampleTrack2;
    private Track sampleTrack3;

    @BeforeEach
    void setUp() {
        samplePlaylist = new Playlist("Test Playlist", true);
        sampleTrack1 = new Track("Bohemian Rhapsody", "Queen", 355);
        sampleTrack2 = new Track("Stairway to Heaven", "Led Zeppelin", 482);
        sampleTrack3 = new Track("Hotel California", "Eagles", 391);
    }

    @Nested
    @DisplayName("Playlist Creation")
    class PlaylistCreation {

        @Test
        @DisplayName("Should create playlist successfully")
        void shouldCreatePlaylistSuccessfully() {
            // Given
            String name = "My Awesome Playlist";
            Boolean isPublic = false;
            Playlist expectedPlaylist = new Playlist(name, isPublic);
            
            when(playlistRepository.save(any(Playlist.class))).thenReturn(expectedPlaylist);

            // When
            Playlist result = playlistService.createPlaylist(name, isPublic);

            // Then
            assertNotNull(result);
            assertEquals(name, result.getName());
            assertEquals(isPublic, result.getIsPublic());
            
            verify(playlistRepository, times(1)).save(any(Playlist.class));
        }

        @Test
        @DisplayName("Should delegate ID generation to domain entity")
        void shouldDelegateIdGenerationToDomainEntity() {
            // Given
            when(playlistRepository.save(any(Playlist.class))).thenReturn(samplePlaylist);

            // When
            Playlist result = playlistService.createPlaylist("Test Playlist", true);

            // Then
            assertNotNull(result.getId(), "Playlist should have ID generated by domain entity");
            
            verify(playlistRepository).save(argThat(playlist -> playlist.getId() != null));
        }
    }

    @Nested
    @DisplayName("Playlist Retrieval")
    class PlaylistRetrieval {

        @Test
        @DisplayName("Should retrieve all playlists successfully")
        void shouldRetrieveAllPlaylistsSuccessfully() {
            // Given
            Playlist playlist1 = new Playlist("Playlist 1", true);
            Playlist playlist2 = new Playlist("Playlist 2", false);
            List<Playlist> expectedPlaylists = Arrays.asList(playlist1, playlist2);
            
            when(playlistRepository.findAll()).thenReturn(expectedPlaylists);

            // When
            List<Playlist> result = playlistService.getAllPlaylists();

            // Then
            assertEquals(2, result.size());
            assertEquals(expectedPlaylists, result);
            
            verify(playlistRepository, times(1)).findAll();
        }

        @Test
        @DisplayName("Should retrieve playlist by ID successfully")
        void shouldRetrievePlaylistByIdSuccessfully() {
            // Given
            String playlistId = "test-playlist-id";
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));

            // When
            Playlist result = playlistService.getPlaylistById(playlistId);

            // Then
            assertEquals(samplePlaylist, result);
            
            verify(playlistRepository, times(1)).findById(playlistId);
        }

        @Test
        @DisplayName("Should throw PlaylistNotFoundException when playlist not found")
        void shouldThrowPlaylistNotFoundExceptionWhenPlaylistNotFound() {
            // Given
            String nonExistentId = "non-existent-id";
            when(playlistRepository.findById(nonExistentId)).thenReturn(Optional.empty());

            // When & Then
            PlaylistNotFoundException exception = assertThrows(
                PlaylistNotFoundException.class,
                () -> playlistService.getPlaylistById(nonExistentId)
            );
            
            assertTrue(exception.getMessage().contains(nonExistentId));
            verify(playlistRepository, times(1)).findById(nonExistentId);
        }

        @Test
        @DisplayName("Should get playlist tracks successfully")
        void shouldGetPlaylistTracksSuccessfully() {
            // Given
            String playlistId = "test-playlist-id";
            samplePlaylist.addTrack(sampleTrack1);
            samplePlaylist.addTrack(sampleTrack2);
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));

            // When
            List<Track> result = playlistService.getPlaylistTracks(playlistId);

            // Then
            assertEquals(2, result.size());
            assertTrue(result.contains(sampleTrack1));
            assertTrue(result.contains(sampleTrack2));
            
            verify(playlistRepository, times(1)).findById(playlistId);
        }
    }

    @Nested
    @DisplayName("Playlist Updates")
    class PlaylistUpdates {

        @Test
        @DisplayName("Should update playlist successfully")
        void shouldUpdatePlaylistSuccessfully() {
            // Given
            String playlistId = "existing-playlist-id";
            String newName = "Updated Playlist Name";
            Boolean newIsPublic = false;
            
            Playlist existingPlaylist = new Playlist("Original Name", true);
            Playlist updatedPlaylist = new Playlist(newName, newIsPublic);
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(existingPlaylist));
            when(playlistRepository.save(existingPlaylist)).thenReturn(updatedPlaylist);

            // When
            Playlist result = playlistService.updatePlaylist(playlistId, newName, newIsPublic);

            // Then
            assertEquals(newName, existingPlaylist.getName());
            assertEquals(newIsPublic, existingPlaylist.getIsPublic());
            
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(playlistRepository, times(1)).save(existingPlaylist);
        }

        @Test
        @DisplayName("Should throw exception when updating non-existent playlist")
        void shouldThrowExceptionWhenUpdatingNonExistentPlaylist() {
            // Given
            String nonExistentId = "non-existent-id";
            when(playlistRepository.findById(nonExistentId)).thenReturn(Optional.empty());

            // When & Then
            PlaylistNotFoundException exception = assertThrows(
                PlaylistNotFoundException.class,
                () -> playlistService.updatePlaylist(nonExistentId, "New Name", true)
            );
            
            assertTrue(exception.getMessage().contains(nonExistentId));
            verify(playlistRepository, times(1)).findById(nonExistentId);
            verify(playlistRepository, never()).save(any(Playlist.class));
        }
    }

    @Nested
    @DisplayName("Playlist Deletion")
    class PlaylistDeletion {

        @Test
        @DisplayName("Should delete playlist successfully")
        void shouldDeletePlaylistSuccessfully() {
            // Given
            String playlistId = "existing-playlist-id";
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));

            // When
            assertDoesNotThrow(() -> playlistService.deletePlaylist(playlistId));

            // Then
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(playlistRepository, times(1)).delete(samplePlaylist);
        }

        @Test
        @DisplayName("Should throw exception when deleting non-existent playlist")
        void shouldThrowExceptionWhenDeletingNonExistentPlaylist() {
            // Given
            String nonExistentId = "non-existent-id";
            when(playlistRepository.findById(nonExistentId)).thenReturn(Optional.empty());

            // When & Then
            PlaylistNotFoundException exception = assertThrows(
                PlaylistNotFoundException.class,
                () -> playlistService.deletePlaylist(nonExistentId)
            );
            
            assertTrue(exception.getMessage().contains(nonExistentId));
            verify(playlistRepository, times(1)).findById(nonExistentId);
            verify(playlistRepository, never()).delete(any(Playlist.class));
        }
    }

    @Nested
    @DisplayName("Adding Single Track")
    class AddingSingleTrack {

        @Test
        @DisplayName("Should add track to playlist successfully")
        void shouldAddTrackToPlaylistSuccessfully() {
            // Given
            String playlistId = "playlist-id";
            String trackId = "track-id";
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById(trackId)).thenReturn(sampleTrack1);
            when(playlistRepository.save(samplePlaylist)).thenReturn(samplePlaylist);

            // When
            Playlist result = playlistService.addTrackToPlaylist(playlistId, trackId);

            // Then
            assertNotNull(result);
            assertTrue(samplePlaylist.getTracks().contains(sampleTrack1));
            assertEquals(1, samplePlaylist.getTrackCount());
            
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(trackService, times(1)).getTrackById(trackId);
            verify(playlistRepository, times(1)).save(samplePlaylist);
        }

        @Test
        @DisplayName("Should propagate TrackNotFoundException when track not found")
        void shouldPropagateTrackNotFoundExceptionWhenTrackNotFound() {
            // Given
            String playlistId = "playlist-id";
            String nonExistentTrackId = "non-existent-track-id";
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById(nonExistentTrackId))
                .thenThrow(new TrackNotFoundException(nonExistentTrackId));

            // When & Then
            TrackNotFoundException exception = assertThrows(
                TrackNotFoundException.class,
                () -> playlistService.addTrackToPlaylist(playlistId, nonExistentTrackId)
            );
            
            assertTrue(exception.getMessage().contains(nonExistentTrackId));
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(trackService, times(1)).getTrackById(nonExistentTrackId);
            verify(playlistRepository, never()).save(any(Playlist.class));
        }

        @Test
        @DisplayName("Should add track at specific position successfully")
        void shouldAddTrackAtSpecificPositionSuccessfully() {
            // Given
            String playlistId = "playlist-id";
            String trackId = "track-id";
            int position = 0;
            
            samplePlaylist.addTrack(sampleTrack2); // Add existing track first
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById(trackId)).thenReturn(sampleTrack1);
            when(playlistRepository.save(samplePlaylist)).thenReturn(samplePlaylist);

            // When
            Playlist result = playlistService.addTrackAtPosition(playlistId, trackId, position);

            // Then
            assertNotNull(result);
            List<Track> tracks = samplePlaylist.getTracks();
            assertEquals(sampleTrack1, tracks.get(0)); // Should be at position 0
            assertEquals(sampleTrack2, tracks.get(1)); // Should be pushed to position 1
            
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(trackService, times(1)).getTrackById(trackId);
            verify(playlistRepository, times(1)).save(samplePlaylist);
        }

        @Test
        @DisplayName("Should propagate InvalidTrackPositionException for invalid position")
        void shouldPropagateInvalidTrackPositionExceptionForInvalidPosition() {
            // Given
            String playlistId = "playlist-id";
            String trackId = "track-id";
            int invalidPosition = 10; // Way beyond playlist size
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById(trackId)).thenReturn(sampleTrack1);

            // When & Then
            InvalidTrackPositionException exception = assertThrows(
                InvalidTrackPositionException.class,
                () -> playlistService.addTrackAtPosition(playlistId, trackId, invalidPosition)
            );
            
            assertTrue(exception.getMessage().contains("Invalid track position"));
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(trackService, times(1)).getTrackById(trackId);
            verify(playlistRepository, never()).save(any(Playlist.class));
        }
    }

    @Nested
    @DisplayName("Adding Multiple Tracks")
    class AddingMultipleTracks {

        @Test
        @DisplayName("Should add multiple tracks at end when position is null")
        void shouldAddMultipleTracksAtEndWhenPositionIsNull() {
            // Given
            String playlistId = "playlist-id";
            List<String> trackIds = Arrays.asList("track1-id", "track2-id");
            AddMultipleTracksRequest request = new AddMultipleTracksRequest(trackIds, null);
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById("track1-id")).thenReturn(sampleTrack1);
            when(trackService.getTrackById("track2-id")).thenReturn(sampleTrack2);
            when(playlistRepository.save(samplePlaylist)).thenReturn(samplePlaylist);

            // When
            Playlist result = playlistService.addMultipleTracks(playlistId, request);

            // Then
            assertNotNull(result);
            assertEquals(2, samplePlaylist.getTrackCount());
            assertTrue(samplePlaylist.getTracks().contains(sampleTrack1));
            assertTrue(samplePlaylist.getTracks().contains(sampleTrack2));
            
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(trackService, times(1)).getTrackById("track1-id");
            verify(trackService, times(1)).getTrackById("track2-id");
            verify(playlistRepository, times(1)).save(samplePlaylist);
        }

        @Test
        @DisplayName("Should add multiple tracks at specific position")
        void shouldAddMultipleTracksAtSpecificPosition() {
            // Given
            String playlistId = "playlist-id";
            List<String> trackIds = Arrays.asList("track1-id", "track2-id");
            AddMultipleTracksRequest request = new AddMultipleTracksRequest(trackIds, 0);
            
            samplePlaylist.addTrack(sampleTrack3); // Add existing track
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById("track1-id")).thenReturn(sampleTrack1);
            when(trackService.getTrackById("track2-id")).thenReturn(sampleTrack2);
            when(playlistRepository.save(samplePlaylist)).thenReturn(samplePlaylist);

            // When
            Playlist result = playlistService.addMultipleTracks(playlistId, request);

            // Then
            assertNotNull(result);
            assertEquals(3, samplePlaylist.getTrackCount());
            List<Track> tracks = samplePlaylist.getTracks();
            assertEquals(sampleTrack1, tracks.get(0)); // Should be at position 0
            assertEquals(sampleTrack2, tracks.get(1)); // Should be at position 1
            assertEquals(sampleTrack3, tracks.get(2)); // Should be pushed to position 2
            
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(trackService, times(1)).getTrackById("track1-id");
            verify(trackService, times(1)).getTrackById("track2-id");
            verify(playlistRepository, times(1)).save(samplePlaylist);
        }

        @Test
        @DisplayName("Should propagate TrackNotFoundException when any track not found")
        void shouldPropagateTrackNotFoundExceptionWhenAnyTrackNotFound() {
            // Given
            String playlistId = "playlist-id";
            List<String> trackIds = Arrays.asList("track1-id", "non-existent-track-id");
            AddMultipleTracksRequest request = new AddMultipleTracksRequest(trackIds, null);
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById("track1-id")).thenReturn(sampleTrack1);
            when(trackService.getTrackById("non-existent-track-id"))
                .thenThrow(new TrackNotFoundException("non-existent-track-id"));

            // When & Then
            TrackNotFoundException exception = assertThrows(
                TrackNotFoundException.class,
                () -> playlistService.addMultipleTracks(playlistId, request)
            );
            
            assertTrue(exception.getMessage().contains("non-existent-track-id"));
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(trackService, times(1)).getTrackById("track1-id");
            verify(trackService, times(1)).getTrackById("non-existent-track-id");
            verify(playlistRepository, never()).save(any(Playlist.class));
        }

        @Test
        @DisplayName("Should propagate InvalidTrackPositionException for invalid position in multiple tracks")
        void shouldPropagateInvalidTrackPositionExceptionForInvalidPositionInMultipleTracks() {
            // Given
            String playlistId = "playlist-id";
            List<String> trackIds = Arrays.asList("track1-id", "track2-id");
            AddMultipleTracksRequest request = new AddMultipleTracksRequest(trackIds, 10);
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById("track1-id")).thenReturn(sampleTrack1);
            when(trackService.getTrackById("track2-id")).thenReturn(sampleTrack2);

            // When & Then
            InvalidTrackPositionException exception = assertThrows(
                InvalidTrackPositionException.class,
                () -> playlistService.addMultipleTracks(playlistId, request)
            );
            
            assertTrue(exception.getMessage().contains("Invalid track position"));
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(trackService, times(1)).getTrackById("track1-id");
            verify(trackService, times(1)).getTrackById("track2-id");
            verify(playlistRepository, never()).save(any(Playlist.class));
        }
    }

    @Nested
    @DisplayName("Service Coordination Verification")
    class ServiceCoordinationVerification {

        @Test
        @DisplayName("Should coordinate between services correctly")
        void shouldCoordinateBetweenServicesCorrectly() {
            // Given
            String playlistId = "playlist-id";
            String trackId = "track-id";
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById(trackId)).thenReturn(sampleTrack1);
            when(playlistRepository.save(samplePlaylist)).thenReturn(samplePlaylist);

            // When
            playlistService.addTrackToPlaylist(playlistId, trackId);

            // Then - Verify proper service coordination
            verify(playlistRepository, times(1)).findById(playlistId);
            verify(trackService, times(1)).getTrackById(trackId);
            verify(playlistRepository, times(1)).save(samplePlaylist);
            
            // Verify no unexpected interactions
            verifyNoMoreInteractions(playlistRepository);
            verifyNoMoreInteractions(trackService);
        }

        @Test
        @DisplayName("Should not save when domain validation fails")
        void shouldNotSaveWhenDomainValidationFails() {
            // Given
            String playlistId = "playlist-id";
            String trackId = "track-id";
            int invalidPosition = -1;
            
            when(playlistRepository.findById(playlistId)).thenReturn(Optional.of(samplePlaylist));
            when(trackService.getTrackById(trackId)).thenReturn(sampleTrack1);

            // When & Then
            assertThrows(
                InvalidTrackPositionException.class,
                () -> playlistService.addTrackAtPosition(playlistId, trackId, invalidPosition)
            );
            
            // Verify save was never called due to domain validation failure
            verify(playlistRepository, never()).save(any(Playlist.class));
        }
    }
}