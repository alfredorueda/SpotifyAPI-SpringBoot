package com.spotify.unit.service;

import com.spotify.domain.entities.Track;
import com.spotify.domain.exceptions.TrackNotFoundException;
import com.spotify.repositories.TrackRepository;
import com.spotify.services.TrackService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

/**
 * Unit tests for TrackService using Mockito to mock repository dependencies.
 * These tests focus on service layer coordination logic without testing persistence.
 * 
 * @Tag("unit") allows running only unit tests with: mvn test -Dtest="*Test" -Dgroups="unit"
 */
@Tag("unit")
@ExtendWith(MockitoExtension.class)
@DisplayName("TrackService Unit Tests")
class TrackServiceTest {

    @Mock
    private TrackRepository trackRepository;

    @InjectMocks
    private TrackService trackService;

    private Track sampleTrack;

    @BeforeEach
    void setUp() {
        sampleTrack = new Track("Bohemian Rhapsody", "Queen", 355);
    }

    @Nested
    @DisplayName("Track Creation")
    class TrackCreation {

        @Test
        @DisplayName("Should create track successfully")
        void shouldCreateTrackSuccessfully() {
            // Given
            String title = "Stairway to Heaven";
            String artist = "Led Zeppelin";
            Integer duration = 482;
            Track expectedTrack = new Track(title, artist, duration);
            
            when(trackRepository.save(any(Track.class))).thenReturn(expectedTrack);

            // When
            Track result = trackService.createTrack(title, artist, duration);

            // Then
            assertNotNull(result);
            assertEquals(title, result.getTitle());
            assertEquals(artist, result.getArtist());
            assertEquals(duration, result.getDuration());
            
            // Verify repository interaction
            verify(trackRepository, times(1)).save(any(Track.class));
        }

        @Test
        @DisplayName("Should delegate ID generation to domain entity")
        void shouldDelegateIdGenerationToDomainEntity() {
            // Given
            when(trackRepository.save(any(Track.class))).thenReturn(sampleTrack);

            // When
            Track result = trackService.createTrack("Test Title", "Test Artist", 200);

            // Then
            assertNotNull(result.getId(), "Track should have ID generated by domain entity");
            
            // Verify that the service doesn't generate IDs itself
            verify(trackRepository).save(argThat(track -> track.getId() != null));
        }
    }

    @Nested
    @DisplayName("Track Retrieval")
    class TrackRetrieval {

        @Test
        @DisplayName("Should retrieve all tracks successfully")
        void shouldRetrieveAllTracksSuccessfully() {
            // Given
            Track track1 = new Track("Song 1", "Artist 1", 200);
            Track track2 = new Track("Song 2", "Artist 2", 250);
            List<Track> expectedTracks = Arrays.asList(track1, track2);
            
            when(trackRepository.findAll()).thenReturn(expectedTracks);

            // When
            List<Track> result = trackService.getAllTracks();

            // Then
            assertEquals(2, result.size());
            assertEquals(expectedTracks, result);
            
            verify(trackRepository, times(1)).findAll();
        }

        @Test
        @DisplayName("Should retrieve track by ID successfully")
        void shouldRetrieveTrackByIdSuccessfully() {
            // Given
            String trackId = "test-track-id";
            when(trackRepository.findById(trackId)).thenReturn(Optional.of(sampleTrack));

            // When
            Track result = trackService.getTrackById(trackId);

            // Then
            assertEquals(sampleTrack, result);
            
            verify(trackRepository, times(1)).findById(trackId);
        }

        @Test
        @DisplayName("Should throw TrackNotFoundException when track not found")
        void shouldThrowTrackNotFoundExceptionWhenTrackNotFound() {
            // Given
            String nonExistentId = "non-existent-id";
            when(trackRepository.findById(nonExistentId)).thenReturn(Optional.empty());

            // When & Then
            TrackNotFoundException exception = assertThrows(
                TrackNotFoundException.class,
                () -> trackService.getTrackById(nonExistentId)
            );
            
            assertTrue(exception.getMessage().contains(nonExistentId));
            verify(trackRepository, times(1)).findById(nonExistentId);
        }
    }

    @Nested
    @DisplayName("Track Updates")
    class TrackUpdates {

        @Test
        @DisplayName("Should update track successfully")
        void shouldUpdateTrackSuccessfully() {
            // Given
            String trackId = "existing-track-id";
            String newTitle = "Updated Title";
            String newArtist = "Updated Artist";
            Integer newDuration = 300;
            
            Track existingTrack = new Track("Original Title", "Original Artist", 200);
            Track updatedTrack = new Track(newTitle, newArtist, newDuration);
            
            when(trackRepository.findById(trackId)).thenReturn(Optional.of(existingTrack));
            when(trackRepository.save(existingTrack)).thenReturn(updatedTrack);

            // When
            Track result = trackService.updateTrack(trackId, newTitle, newArtist, newDuration);

            // Then
            assertEquals(newTitle, existingTrack.getTitle());
            assertEquals(newArtist, existingTrack.getArtist());
            assertEquals(newDuration, existingTrack.getDuration());
            
            verify(trackRepository, times(1)).findById(trackId);
            verify(trackRepository, times(1)).save(existingTrack);
        }

        @Test
        @DisplayName("Should throw exception when updating non-existent track")
        void shouldThrowExceptionWhenUpdatingNonExistentTrack() {
            // Given
            String nonExistentId = "non-existent-id";
            when(trackRepository.findById(nonExistentId)).thenReturn(Optional.empty());

            // When & Then
            TrackNotFoundException exception = assertThrows(
                TrackNotFoundException.class,
                () -> trackService.updateTrack(nonExistentId, "New Title", "New Artist", 300)
            );
            
            assertTrue(exception.getMessage().contains(nonExistentId));
            verify(trackRepository, times(1)).findById(nonExistentId);
            verify(trackRepository, never()).save(any(Track.class));
        }
    }

    @Nested
    @DisplayName("Track Deletion")
    class TrackDeletion {

        @Test
        @DisplayName("Should delete track successfully")
        void shouldDeleteTrackSuccessfully() {
            // Given
            String trackId = "existing-track-id";
            when(trackRepository.findById(trackId)).thenReturn(Optional.of(sampleTrack));

            // When
            assertDoesNotThrow(() -> trackService.deleteTrack(trackId));

            // Then
            verify(trackRepository, times(1)).findById(trackId);
            verify(trackRepository, times(1)).delete(sampleTrack);
        }

        @Test
        @DisplayName("Should throw exception when deleting non-existent track")
        void shouldThrowExceptionWhenDeletingNonExistentTrack() {
            // Given
            String nonExistentId = "non-existent-id";
            when(trackRepository.findById(nonExistentId)).thenReturn(Optional.empty());

            // When & Then
            TrackNotFoundException exception = assertThrows(
                TrackNotFoundException.class,
                () -> trackService.deleteTrack(nonExistentId)
            );
            
            assertTrue(exception.getMessage().contains(nonExistentId));
            verify(trackRepository, times(1)).findById(nonExistentId);
            verify(trackRepository, never()).delete(any(Track.class));
        }
    }

    @Nested
    @DisplayName("Repository Interaction Verification")
    class RepositoryInteractionVerification {

        @Test
        @DisplayName("Should only call repository methods once per operation")
        void shouldOnlyCallRepositoryMethodsOncePerOperation() {
            // Given
            when(trackRepository.findById("test-id")).thenReturn(Optional.of(sampleTrack));
            when(trackRepository.save(any(Track.class))).thenReturn(sampleTrack);

            // When
            trackService.getTrackById("test-id");
            trackService.createTrack("Test", "Test", 200);

            // Then
            verify(trackRepository, times(1)).findById("test-id");
            verify(trackRepository, times(1)).save(any(Track.class));
        }

        @Test
        @DisplayName("Should not interact with repository for business logic validation")
        void shouldNotInteractWithRepositoryForBusinessLogicValidation() {
            // Given - Creating a track should not require additional repository calls
            when(trackRepository.save(any(Track.class))).thenReturn(sampleTrack);

            // When
            Track result = trackService.createTrack("Valid Title", "Valid Artist", 200);

            // Then
            assertNotNull(result);
            // Only save should be called, no finds or other operations
            verify(trackRepository, times(1)).save(any(Track.class));
            verify(trackRepository, never()).findById(any());
            verify(trackRepository, never()).findAll();
        }
    }
}